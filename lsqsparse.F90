#include "fintrf.h"
!
	  SUBROUTINE MEXFUNCTION(NLHS, PLHS, NRHS, PRHS)
!
!     This is the gateway subroutine for LSQSPARSE mex function
!
	  USE SPARSEREG
	  IMPLICIT NONE
!
!     MEXFUNCTION ARGUMENTS
!
	  MWPOINTER :: PLHS(*), PRHS(*)
	  INTEGER :: NLHS, NRHS
!
!     FUNCTION DECLARATIONS
!
	  INTEGER :: MXISCHAR,MXISLOGICAL,MXISNUMERIC
	  INTEGER*4 :: MEXPRINTF
	  MWPOINTER :: MXCREATEDOUBLEMATRIX,MXGETPR,MXGETSTRING
	  MWSIZE :: MXGETM, MXGETN
!
!     SOME LOCAL VARIABLES
!		
      INTEGER :: MAXITERS,STATUS
      MWSIZE :: N,P,PENNAMELEN,PENPARAMS
      REAL(KIND=DBLE_PREC) :: MAXITERSREAL,LAMBDA
      CHARACTER(LEN=10) :: PENTYPE
      LOGICAL, ALLOCATABLE, DIMENSION(:) :: PENIDX
      REAL(KIND=DBLE_PREC), ALLOCATABLE, DIMENSION(:) :: ESTIMATE,PENPARAM,SUM_X_SQUARES,WT,Y
      REAL(KIND=DBLE_PREC), ALLOCATABLE, DIMENSION(:,:) :: X
!
!     CHECK FOR INPUT ARGUMENT TYPES
!
      IF (NRHS.NE.10) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:nInput','Ten input requried.')
      ELSEIF (NLHS.NE.1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:nOutput','One output requried.')
      ELSEIF (MXISNUMERIC(PRHS(1))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input1','Input 1 must be a numerical array.')
      ELSEIF (MXISNUMERIC(PRHS(2))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input2','Input 2 must be a numerical array.')
      ELSEIF (MXISNUMERIC(PRHS(3))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input3','Input 3 must be a numerical array.')
      ELSEIF (MXISNUMERIC(PRHS(4))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input4','Input 4 must be a numerical array.')
      ELSEIF (MXISNUMERIC(PRHS(5))/=1.OR.MXGETM(PRHS(5))*MXGETN(PRHS(5))>1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input5','Input 5 must be a scalar.')
      ELSEIF (MXISNUMERIC(PRHS(6))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input6','Input 6 must be a numerical array.')
      ELSEIF (MXISLOGICAL(PRHS(7))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input7','Input 7 must be a numerical array.')
      ELSEIF (MXISNUMERIC(PRHS(8))/=1.OR.MXGETM(PRHS(8))*MXGETN(PRHS(8))>1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input8','Input 8 must be a scalar.')
      ELSEIF (MXISCHAR(PRHS(9))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input9','Input 9 must be a string.')
      ELSEIF (MXISNUMERIC(PRHS(10))/=1) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:Input10','Input 10 must be a numerical array.')
      END IF
!
!     PREPARE INPUTS FOR COMPUTATIONAL ROUTINE
!
      N = MXGETM(PRHS(2))
      P = MXGETN(PRHS(2))
      ALLOCATE(ESTIMATE(P))
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(1)),ESTIMATE,P)
      ALLOCATE(X(N,P))
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(2)),X,N*P)
      ALLOCATE(Y(N))
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(3)),Y,N)
      ALLOCATE(WT(N))
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(4)),WT,N)
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(5)),LAMBDA,1)
      ALLOCATE(SUM_X_SQUARES(P))
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(6)),SUM_X_SQUARES,P)
      ALLOCATE(PENIDX(P))
      CALL MXCOPYPTRTOLOGICAL(MXGETPR(PRHS(7)),PENIDX,P)
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(8)),MAXITERSREAL,1)
      MAXITERS = INT(MAXITERSREAL,KIND(MAXITERS))
      PENNAMELEN = MXGETM(PRHS(9))*MXGETN(PRHS(9))
      STATUS = MXGETSTRING(PRHS(9), PENTYPE, PENNAMELEN)
      IF (STATUS/=0) THEN
         CALL MEXERRMSGIDANDTXT('MATLAB:lsqsparse:readError','Error reading string.')
      END IF
      PENPARAMS = MXGETM(PRHS(10))*MXGETN(PRHS(10))
      ALLOCATE(PENPARAM(PENPARAMS))
      CALL MXCOPYPTRTOREAL8(MXGETPR(PRHS(10)),PENPARAM,PENPARAMS)      
!
!     CALL THE COMPUTATION ROUTINE
!
      CALL PENALIZED_L2_REGRESSION(ESTIMATE,X,Y,WT,LAMBDA, &
         SUM_X_SQUARES,PENIDX,MAXITERS,PENTYPE(1:PENNAMELEN),PENPARAM)
!
!     COPY RESULT TO MATLAB ARRAYS
!
      PLHS(1) = MXCREATEDOUBLEMATRIX(P,1,0)
      CALL MXCOPYREAL8TOPTR(ESTIMATE,MXGETPR(PLHS(1)),P)
!
!     FREE MEMORY
!
      DEALLOCATE (ESTIMATE,X,Y,WT,SUM_X_SQUARES,PENIDX,PENPARAM)
      RETURN
		END SUBROUTINE MEXFUNCTION

      SUBROUTINE MXCOPYPTRTOLOGICAL( PTR, FORTRAN, N )
      IMPLICIT NONE
      MWSIZE, INTENT(IN) :: N
      MWPOINTER, INTENT(IN) :: PTR
      LOGICAL, INTENT(OUT) :: FORTRAN(N)
      INTEGER*1 :: LOGICALDATA(N)      
      CALL mxCopyPtrToInteger1(PTR, LOGICALDATA, N)
      FORTRAN = (LOGICALDATA /= 0)
      RETURN
      END SUBROUTINE

